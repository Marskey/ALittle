
namespace ALittleIDE;

public class IDECodeCursor : ALittle.Quad
{
    private double _flash_alpha = 0;
    private double _flash_dir = 0.05;
    private ALittle.LoopFunction _loop;

    private IDECodeTabChild _tab_child;

    // 单光标的位置
    private int _it_line = 1;
    private int _it_char = 0;

    public ctor(ALittle.ControlSystem ctrl_sys, IDECodeTabChild tab_child)
    {
        this._tab_child = tab_child;
    }

    public get line() : int { return this._it_line; }
    public get char() : int { return this._it_char; }

    public fun Show([Nullable]double x, [Nullable]double y)
    {
        if (this._loop == null) this._loop = new ALittle.LoopFunction(bind(this.Update, this), -1, 1, 1);
        if (!A_LoopSystem.HasUpdater(this._loop)) A_LoopSystem.AddUpdater(this._loop);
        this.visible = true;
    }

    // 根据当前光标选中文本
    public fun CalcSelectWord() : int, int
    {
        var line = this._tab_child.line_list[this._it_line];
        if (line == null) return null, null;

        var count = line.char_count;
        while (count > 0 && line.char_list[count].width <= 0)
            -- count;
        // 从当前光标向后找
        var it_end = this._it_char;
        for (var i = this._it_char + 1; i <= count; 1)
        {
            var char = line.char_list[i].char;
            var byte = ALittle.String_Byte(char, 1);
            var check = byte >= 65 && byte <= 90
                        || byte >= 97 && byte <= 122
                        || byte == 95;
            if (!check) break;
            it_end = i;
        }
        // 从当前光标向前找
        var it_start = this._it_char;
        for (var i = this._it_char; i >= 1; -1)
        {
            var char = line.char_list[i].char;
            var byte = ALittle.String_Byte(char, 1);
            var check = byte >= 65 && byte <= 90
                        || byte >= 97 && byte <= 122
                        || byte == 95;
            it_start = i;
            if (!check) break;
        }
        if (it_start == it_end) return null, null;
        return it_start, it_end;
    }

    public fun SetOffsetXY(double x, double y, [Nullable]bool show)
    {
        if (this._tab_child.line_count <= 0)
        {
            this._it_line = 1;
            this._it_char = 0;
        }
        else
        {
            this._it_line, this._it_char = this._tab_child.CalcLineAndChar(x, y);
        }

        this.y = (this._it_line - 1) * this._tab_child.line_height;
        var line = this._tab_child.line_list[this._it_line];
        if (line == null || this._it_char == 0)
            this.x = 0;
        else
        {
            var char = line.char_list[this._it_char];
            this.x = char.pre_width + char.width;
        }   
        if (show == null || show) this.Show();
    }

    public fun SetLineChar(int it_line, int it_char, [Nullable]bool show)
    {
        this._it_line = it_line;
        this._it_char = it_char;

        this.y = (this._it_line - 1) * this._tab_child.line_height;
        var line = this._tab_child.line_list[this._it_line];
        if (line == null || this._it_char <= 0)
            this.x = 0;
        else
            this.x = line.char_list[this._it_char].pre_width + line.char_list[this._it_char].width;
        if (show == null || show)
            this.Show();
    }

    // 向上移动一行
    public fun OffsetUp()
    {
        if (this._it_line <= 1) return;
        var it_line = this._it_line - 1;
        var line = this._tab_child.line_list[it_line];
        if (line == null) return;

        var it_char = line.char_count;
        while (it_char > 0 && line.char_list[it_char].width <= 0)
            -- it_char;
        if (this._it_char < it_char) it_char = this._it_char;

        this.SetLineChar(it_line, it_char, false);
    }

    // 向下移动一行
    public fun OffsetDown()
    {
        if (this._it_line >= this._tab_child.line_count) return;
        var it_line = this._it_line + 1;
        var line = this._tab_child.line_list[it_line];
        if (line == null) return;
        var it_char = line.char_count;
        while (it_char > 0 && line.char_list[it_char].width <= 0)
            -- it_char;
        if (this._it_char < it_char) it_char = this._it_char;
        this.SetLineChar(it_line, it_char, false);
    }

    // 向左移动一格
    public fun OffsetLeft()
    {
        if (this._it_char > 0)
        {
            this.SetLineChar(this._it_line, this._it_char - 1, false);
            return;
        }

        if (this._it_line > 1)
        {
            var it_line = this._it_line - 1;
            var line = this._tab_child.line_list[it_line];
            var it_char = line.char_count;
            while (it_char > 0 && line.char_list[it_char].width <= 0)
                -- it_char;
            this.SetLineChar(it_line, it_char, false);
            return;
        }

        this.SetLineChar(1, 0, false);
    }

    // 向右移动一格
    public fun OffsetRight()
    {
        if (this._tab_child.line_count <= 0) return;
        var line = this._tab_child.line_list[this._it_line];
        var count = line.char_count;
        while (count > 0 && line.char_list[count].width <= 0)
            -- count;
        if (this._it_char < count)
        {
            this.SetLineChar(this._it_line, this._it_char + 1, false);
            return;
        }
        if (this._it_line >= this._tab_child.line_count)
        {
            return;
        }

        this.SetLineChar(this._it_line + 1, 0, false);
    }

    // 向第一个字符
    public fun OffsetHome()
    {
        if (this._it_char <= 0) return;
        var line = this._tab_child.line_list[this._it_line];
        if (line == null) return;
        var it_char = 1;
        while (it_char <= line.char_count)
        {
            var char = line.char_list[it_char];
            if (char.char != " " && char.char != "\t")
                break;
            ++it_char;
        }
        if (this._it_char == it_char - 1)
            this.SetLineChar(this._it_line, 0, false);
        else
            this.SetLineChar(this._it_line, it_char - 1, false);
    }

    // 向最后一列
    public fun OffsetEnd()
    {
        var line = this._tab_child.line_list[this._it_line];
        if (line == null) return;
        var count = line.char_count;
        while (count > 0 && line.char_list[count].width <= 0)
            -- count;
        if (this._it_char < count)
            this.SetLineChar(this._it_line, count, false);
    }

    // 向前删除一个字符
    public fun DeleteLeft() : bool
    {
        // 如果不在第一列
        if (this._it_char > 0)
        {
            var line = this._tab_child.line_list[this._it_line];
            if (line == null) return false;

            var char = line.char_list[this._it_char];
            if (char.text != null) line.container.RemoveChild(char.text);
            line.char_count -= 1;
            ALittle.List_Remove(line.char_list, this._it_char);
            for (var i = this._it_char; i < line.char_count; 1)
            {
                line.char_list[i].pre_width -= char.width;
                if (line.char_list[i].text != null)
                    line.char_list[i].text.x -= char.width;
            }

            this.SetLineChar(this._it_line, this._it_char - 1);

            var last_char = line.char_list[line.char_count];
            if (last_char != null)
                line.container.width = last_char.pre_width + last_char.width;
            else
                line.container.width = 0;

            var rejust = true;
            for (var index, line_info in this._tab_child.line_list)
            {
                if (line_info.container.width > line.container.width)
                {
                    rejust = false;
                    break;
                }
            }
            if (rejust)
            {
                this._tab_child.tab_screen.container.width = line.container.width;
                this._tab_child.tab_screen.RejustScrollBar();
            }
            return true;
        }

        if (this._it_line <= 1) return false;
        var pre_line = this._tab_child.line_list[this._it_line - 1];
        if (pre_line == null) return false;
        var cur_line = this._tab_child.line_list[this._it_line];
        if (cur_line == null) return false;

        // 1. 删除上一行的\r\n，
        var it_char = pre_line.char_count;
        while (it_char > 0 && pre_line.char_list[it_char].width <= 0)
        {
            pre_line.char_count -= 1;
            pre_line.char_list[it_char] = null;
            it_char -= 1;
        }
        var new_it_line = this._it_line - 1;
        var new_it_char = it_char;
        // 2. 当前行拼到上一行的尾部
        var pre_width = 0.0;
        if (pre_line.char_count > 0)
        {
            var last_char = pre_line.char_list[pre_line.char_count];
            pre_width = last_char.pre_width + last_char.width;
        }
        for (var i = 1; i <= cur_line.char_count; 1)
        {
            var char = cur_line.char_list[i];
            char.pre_width = pre_width;
            if (char.text != null)
            {
                char.text.x = pre_width;
                pre_line.container.AddChild(char.text);
            }
            pre_width += char.width;
            pre_line.char_count += 1;
            pre_line.char_list[pre_line.char_count] = char;
        }
        pre_line.container.width = pre_width;
        this._tab_child.code_container.RemoveChild(cur_line.container);
        this._tab_child.line_count -= 1;
        ALittle.List_Remove(this._tab_child.line_list, this._it_line);
        // 3. 下面的行依次往前移动
        for (var i = this._it_line; i < this._tab_child.line_count; 1)
            this._tab_child.line_list[i].container.y -= this._tab_child.line_height;
        // 设置新的光标位置
        this.SetLineChar(new_it_line, new_it_char);
        if (this._tab_child.tab_screen.container.width < pre_line.container.width)
        {
            this._tab_child.tab_screen.container.width = pre_line.container.width;
            this._tab_child.tab_screen.RejustScrollBar();
        }

        return true;
    }

    // 向后删除一个字符
    public fun DeleteRight() : bool
    {
        var line = this._tab_child.line_list[this._it_line];
        if (line == null) return false;
        var count = line.char_count;
        while (count > 0 && line.char_list[count].width <= 0)
            -- count;

        // 如果不在最后一列
        if (this._it_char < count)
        {
            var char = line.char_list[this._it_char + 1];
            if (char.text != null) line.container.RemoveChild(char.text);
            line.char_count -= 1;
            ALittle.List_Remove(line.char_list, this._it_char + 1);
            for (var i = this._it_char + 1; i < line.char_count; 1)
            {
                line.char_list[i].pre_width -= char.width;
                if (line.char_list[i].text != null)
                    line.char_list[i].text.x -= char.width;
            }

            this.SetLineChar(this._it_line, this._it_char);

            var last_char = line.char_list[line.char_count];
            if (last_char != null)
                line.container.width = last_char.pre_width + last_char.width;
            else
                line.container.width = 0;
            var rejust = true;
            for (var index, line_info in this._tab_child.line_list)
            {
                if (line_info.container.width > line.container.width)
                {
                    rejust = false;
                    break;
                }
            }
            if (rejust)
            {
                this._tab_child.tab_screen.container.width = line.container.width;
                this._tab_child.tab_screen.RejustScrollBar();
            }
            return true;
        }

        if (this._it_line >= this._tab_child.line_count) return false;

        var cur_line = line;
        var next_line = this._tab_child.line_list[this._it_line + 1];
        if (next_line == null) return false;

        // 1. 删除当前行的\r\n，
        var it_char = cur_line.char_count;
        while (it_char > 0 && (cur_line.char_list[it_char].char == "\r" || cur_line.char_list[it_char].char == "\n"))
        {
            cur_line.char_count -= 1;
            cur_line.char_list[it_char] = null;
            it_char -= 1;
        }
        var new_it_line = this._it_line;
        var new_it_char = it_char;
        // 2. 下一行拼到当前行的尾部
        var pre_width = 0.0;
        if (cur_line.char_count > 0)
        {
            var last_char = cur_line.char_list[cur_line.char_count];
            pre_width = last_char.pre_width + last_char.width;
        }
        for (var i = 1; i <= next_line.char_count; 1)
        {
            var char = next_line.char_list[i];
            char.pre_width = pre_width;
            if (char.text != null)
            {
                char.text.x = pre_width;
                cur_line.container.AddChild(char.text);
            }
            pre_width += char.width;
            cur_line.char_count += 1;
            cur_line.char_list[cur_line.char_count] = char;
        }
        cur_line.container.width = pre_width;
        this._tab_child.code_container.RemoveChild(next_line.container);
        this._tab_child.line_count -= 1;
        ALittle.List_Remove(this._tab_child.line_list, this._it_line + 1);
        // 3. 下面的行依次往前移动
        for (var i = this._it_line + 1; i < this._tab_child.line_count; 1)
            this._tab_child.line_list[i].container.y -= this._tab_child.line_height;
        // 设置新的光标位置
        this.SetLineChar(new_it_line, new_it_char);
        if (this._tab_child.tab_screen.container.width < cur_line.container.width)
        {
            this._tab_child.tab_screen.container.width = cur_line.container.width;
            this._tab_child.tab_screen.RejustScrollBar();
        }

        return true;
    }

    public fun Hide()
    {
        if (this._loop != null) this._loop.Stop();
        this.visible = false;
    }

    private fun Update()
    {
        if (this.abs_visible)
        {
            this._flash_alpha = this._flash_alpha + this._flash_dir;
            if ((this._flash_dir < 0 && this._flash_alpha < -0.05) || (this._flash_dir > 0 && this._flash_alpha > 1.5))
                this._flash_dir = -this._flash_dir;
            this.alpha = this._flash_alpha;
        }
    }
}
