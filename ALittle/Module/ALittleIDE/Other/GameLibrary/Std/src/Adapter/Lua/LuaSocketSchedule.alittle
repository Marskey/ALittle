
[Language(Lua)]
namespace Lua;

public enum socket_type
{
    TIMER = 21;     // 定时器
    
    MSG_CONNECT_SUCCEED = 31;   // 连接成功
    MSG_CONNECT_FAILED = 32;    // 连接失败
    MSG_DISCONNECTED = 33;      // 断开连接

	MSG_READ_UINT8 = 34;
	MSG_READ_INT8 = 35;
	MSG_READ_UINT16 = 36;
	MSG_READ_INT16 = 37;
	MSG_READ_UINT32 = 38;
	MSG_READ_INT32 = 39;
	MSG_READ_UINT64 = 40;
	MSG_READ_INT64 = 41;
	MSG_READ_FLOAT = 42;
	MSG_READ_DOUBLE = 43;
	MSG_READ_BINARY = 44;
}

public class LuaSocketSchedule : ALittle.ISchedule
{
    public lua.socket _socket;
    private lua.protobuf_importer _importer;
    private lua.protobuf_factory _factory;
    private Map<string, lua.protobuf_descriptor> _message_map;
    private Map<string, lua.protobuf_enum_descriptor> _enum_map;
    private int _last_time;
    
    public ctor()
    {
        this._socket = lua.socket.create();
        this._message_map = new Map<string, lua.protobuf_descriptor>();
        this._enum_map = new Map<string, lua.protobuf_enum_descriptor>();
    }

    public fun LoadProto(string root_path) : string
    {
        this._message_map = new Map<string, lua.protobuf_descriptor>();
        this._enum_map = new Map<string, lua.protobuf_enum_descriptor>();

        this._importer = lua.protobuf.createimporter(root_path);
        this._factory = lua.protobuf.createfactory();

        var file_map = ALittle.File_GetFileAttrByDir(root_path);
        for (var file_path, _ in file_map)
        {
            if (ALittle.File_GetFileExtByPathAndUpper(file_path) != "PROTO")
                continue;
            var file_descriptor = lua.protobuf.importer_import(this._importer, file_path);
            if (file_descriptor == null) return "文件加载失败:"..file_path;

            var message_count = lua.protobuf.filedescriptor_messagetypecount(file_descriptor);
            for (var i = 0; i < message_count; 1)
            {
                var message_descriptor = lua.protobuf.filedescriptor_messagetype(file_descriptor, i);
                if (message_descriptor == null) continue;
                var message_full_name = lua.protobuf.messagedescriptor_fullname(message_descriptor);
                this._message_map[message_full_name] = message_descriptor;
            }
            
            var enum_count = lua.protobuf.filedescriptor_enumtypecount(file_descriptor);
            for (var i = 0; i < enum_count; 1)
            {
                var enum_descriptor = lua.protobuf.filedescriptor_enumtype(file_descriptor, i);
                if (enum_descriptor == null) continue;
                var enum_full_name = lua.protobuf.enumdescriptor_fullname(enum_descriptor);
                this._enum_map[enum_full_name] = enum_descriptor;
            }
        }
        return null;
    }

    public fun RunInFrame()
    {
        while (true)
        {
            var event = lua.socket.poll(this._socket);
            if (event == null) break;
            
            this.HandleEvent(event);
        }
    }
    
    // 在Lua版本下Run直接阻塞，等待所有事件全部处理完毕才退出
    public fun Run()
    {   
        lua.socket.timer(this._socket, 16);
        while (true)
        {
            var event = lua.socket.poll(this._socket);
            if (event == null) break;
            
            if (event.type == socket_type.TIMER)
            {
                if (this._last_time != null)
                {
                    A_LuaLoopSystem.Update(event.time - this._last_time);
                    A_LuaWeakLoopSystem.Update(event.time - this._last_time);
                }
                this._last_time = event.time;
                lua.socket.timer(this._socket, 16);
            }
            else
            {
                this.HandleEvent(event);
            }
        }
    }

    private fun HandleEvent(lua.socket_event event)
    {
        if (event.type == socket_type.MSG_CONNECT_FAILED)
            ISocket.HandleConnectFailed(event.id);
        elseif (event.type == socket_type.MSG_CONNECT_SUCCEED)
            ISocket.HandleConnectSucceed(event.id);
        elseif (event.type == socket_type.MSG_DISCONNECTED)
            ISocket.HandleDisconnected(event.id);
        elseif (event.type >= socket_type.MSG_READ_INT8 && event.type <= socket_type.MSG_READ_INT64)
            ISocket.HandleReadInt(event.id, event.int_value);
        elseif (event.type >= socket_type.MSG_READ_FLOAT && event.type <= socket_type.MSG_READ_DOUBLE)
            ISocket.HandleReadDouble(event.id, event.double_value);
        elseif (event.type >= socket_type.MSG_READ_BINARY)
        {
            ISocket.HandleReadProtobuf(event.id, event.binary_value);
            lua.socket.freebinary(event.binary_value);
        }
    }
}

public var A_LuaSocketSchedule = new LuaSocketSchedule();