
namespace ALittle;

public struct Event
{
    EventDispatcher target;
}

using EventCallbackTable = Map<EventListener, Map<Functor<(EventListener, Event)>, bool>>;

public class EventListener
{
    protected Map<EventDispatcher, Map<int, bool>> _ref_map;
    
    public ctor()
    {
    }
    
    public fun RemoveFromDispatcher()
    {
        if (this._ref_map == null) return;
        
        for (var d, t in this._ref_map)
        {
            for (var hash_code, vb in t)
            {
                var callback_table = d._listeners[hash_code];
                if (callback_table != null)
                    callback_table[this] = null;
            }
        }
        
        this._ref_map = null;
    }
}

public class EventDispatcher : EventListener
{
    // 侦听对象，保存所有侦听这个控件的逻辑对象，以及它们的回调函数
    protected Map<int, EventCallbackTable> _listeners;
    // 是否禁用，如果_abs_disable为true，那么它调用DispatchEvent时什么都不做
    private bool _abs_disabled;
    
    public ctor()
    {
        this._listeners = new Map<int, EventCallbackTable>();
        this._abs_disabled = false;
    }
    
    // 添加侦听对象：侦听事件类型，侦听对象，以及回调函数
    // event_type 侦听的时间类型
    // object 回调函数的对象
    // callback object的回调函数
    public fun AddEventListener<T:Event>(EventListener object, Functor<(EventListener, T)> callback) : bool
    {
        if (object == null) return false;
        if (callback == null) return false;
        
        var rflt = reflect<T>;
        
        var callback_table = this._listeners[rflt.hash_code];
        if (callback_table == null)
        {
            // 创建回调映射表
            callback_table = new EventCallbackTable();
            // 设置为弱引用表
            // Setweak(callback_table, true, false);
            // 保存表
            this._listeners[rflt.hash_code] = callback_table;
        }

        // 获取当前注册的函数
        var callback_value = callback_table[object];
        // 如果是空的直接赋值
        if (callback_value == null)
        {
            callback_value = new Map<Functor<(EventListener, Event)>, bool>();
            callback_table[object] = callback_value;
        }
        callback_value[callback] = true;
        
        // 注册好相互引用的关系
        var ref_map = object._ref_map;
        if (ref_map == null)
        {
            ref_map = new Map<EventDispatcher, Map<int, bool>>();
            object._ref_map = ref_map;
        }
        var ref_value = ref_map[this];
        if (ref_value == null)
        {
            ref_value = new Map<int, bool>();
            ref_map[this] = ref_value;
        }
        ref_value[rflt.hash_code] = true;
        
        return true;
    }

    // 移除侦听对象：侦听事件类型，侦听对象
    public fun RemoveEventListener<T:Event>(EventListener object, Functor<(EventListener, T)> callback)
    {
        var rflt = reflect<T>;
        
        var callback_table = this._listeners[rflt.hash_code];
        if (callback_table == null) return;
        
        // 将要删除的侦听对象置为nil
        if (callback == null)
        {
            object._ref_map[this] = null;
            callback_table[object] = null;
        }
        else
        {
            var callback_value = callback_table[object];
            if (callback_value == null) return;
            callback_value[callback] = null;
            object._ref_map[this][rflt.hash_code] = null;
        }
    }

    // 清理所有侦听
    public fun ClearEventListener()
    {
        for (var hash_code, callback_table in this._listeners)
        {
            for (var listener, callback_value in callback_table)
            {
                listener._ref_map[this] = null;
            }
        }
        this._listeners = new Map<int, EventCallbackTable>();
    }
    
    // 分发事件
    public fun DispatchEvent<T:Event>(T event)
    {
        var rflt = reflect<T>;
        if (event.target == null) event.target = this;
        
        // 根据事件类型，获得所有侦听者
        var callback_table = this._listeners[rflt.hash_code];
        // 检查event的type属性，如果没有则什么都不做。所以每个event必须要有一个type属性
        if (callback_table == null) return;
        // 遍历所有侦听者
        for (var object, callback_value in callback_table)
        {
            // 依次调用它们的回调函数
            for (var func, _ in callback_value)
            {
                [Language(Lua)]
                func(object, event);
                [Language(JavaScript)]
                cast<javascript.Function>(func).call(object, event);
            }
        }
    }
}