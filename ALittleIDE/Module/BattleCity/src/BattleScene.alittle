
namespace BattleCity;

public class BattleScene : ALittle.DisplayLayout
{
	private ALittle.Quad _quad_up;
	private ALittle.Quad _quad_down;

	private ALittle.TileTable _enemy_tiletable;

    private ALittle.DisplayLayout _player1_contianer;
    private ALittle.DisplayLayout _player2_contianer;
	private ALittle.Text _player1_life;
	private ALittle.Text _player2_life;
	private ALittle.Text _stage_num;

	private ALittle.DisplayLayout _tile_container;
    private Map<int, Map<int, ALittle.Sprite>> _sprite_map;

    private ALittle.DisplayLayout _entity_container;

    private ALittle.DisplayLayout _bullet_container;
    private Map<BattleBullet, bool> _bullet_map;

    private BattleMap _battle_map;
    private ALittle.LoopList _anti_loop;
    private double _cell_size;

    private BattlePlayer _player_1;
    private BattlePlayer _player_2;

    private ALittle.LoopFrame _frame_loop;

    private Map<BattleRole, bool> _enemy_map;
    private int _enemy_count = 0;			// 敌军数量
    private int _generate_enemy_cool = 0;	// 生成敌军冷却时间
    private double _enemy_width = 0;		 // 敌军的宽
    private double _enemy_height = 0;		// 敌军的高

    private fun TCtor()
    {
        this._player_1 = g_Control.CreateControl{BattlePlayer}("battle_player1");
        this._player_2 = g_Control.CreateControl{BattlePlayer}("battle_player2");

        this._cell_size = this._tile_container.width / (13 * 4);
        
        var enemy = g_Control.CreateControl{BattleEnemy}("battle_enemy");
        this._enemy_width = enemy.width;
        this._enemy_height = enemy.height;
    }

    public get cell_size() : double { return this._cell_size; }

    public async fun Show(int stage)
    {
        if (this._anti_loop != null)
        {
            this._anti_loop.Stop();
            this._anti_loop = null;
        }

        this._battle_map = g_Control.LoadMessageFromFile{BattleMap}("Other/Map/stage_"..stage..".map");
        if (this._battle_map == null)
        {
            ALittle.Error("map load filed! Other/Map/stage_"..stage..".map");
            return;
        }

        this._tile_container.RemoveAllChild();
        this._sprite_map = new Map<int, Map<int, ALittle.Sprite>>();

        // 根据数据构建地图
        for (var row, sub_map in this._battle_map.tile_map)
        {
            for (var col, type in sub_map)
                this.SetTileShow(row, col, type);
        }

        this.visible = true;

        // 设置第几关
        this._stage_num.text = stage;

        // 设置生命值
        this._player1_life.text = g_GCenter.player1_data.life;
        this._player2_life.text = g_GCenter.player2_data.life;

        // 初始化敌军个数
        this._enemy_tiletable.RemoveAllChild();
        for (var i = 1; i <= 20; 1)
        {
            var icon = g_Control.CreateControl{ALittle.DisplayObject}("enemy_icon");
            this._enemy_tiletable.AddChild(icon);
        }
        this._enemy_map = new Map<BattleRole, bool>();
        this._enemy_count = 0;
        this._generate_enemy_cool = 1000;

        this._bullet_container.RemoveAllChild();
        this._bullet_map = new Map<BattleBullet, bool>();
    
        this._entity_container.RemoveAllChild();
    
        this._player_1.RemoveFromParent();
        this._player_2.RemoveFromParent();

        this._player1_contianer.visible = g_GCenter.player_count >= 1;
        this._player2_contianer.visible = g_GCenter.player_count >= 2;

        this._quad_up.y = 0;
        this._quad_up.visible = true;
        this._quad_down.y = 0;
        this._quad_down.visible = true;

        this._anti_loop = new ALittle.LoopList();
        var group = new ALittle.LoopGroup();
        group.AddUpdater(new ALittle.LoopLinear(this._quad_up, "y", -this._quad_up.height, 500, 0));
        group.AddUpdater(new ALittle.LoopLinear(this._quad_down, "y", A_UISystem.view_height, 500, 0));
        this._anti_loop.AddUpdater(group);
        this._anti_loop.AddUpdater(new ALittle.LoopTimer(bind(this.Start, this), 0));

        this._anti_loop.Start();

        A_UISystem.keydown_callback = bind(this.HandleKeyDown, this);

        if (this._frame_loop != null)
            this._frame_loop.Stop();
        this._frame_loop = new ALittle.LoopFrame(bind(this.HandleFrame, this));
        this._frame_loop.Start();

        this.GenerateEnemy();
    }

    public fun Hide()
    {
        if (this._frame_loop != null)
        {
            this._frame_loop.Stop();
            this._frame_loop = null;
        }

        if (this._anti_loop != null)
        {
            this._anti_loop.Stop();
            this._anti_loop = null;
        }
    }

    private fun SetTileShow(int row, int col, int type)
    {
        var sub_map = this._sprite_map[row];
        if (sub_map == null)
        {
            sub_map = new Map<int, ALittle.Sprite>();
            this._sprite_map[row] = sub_map;
        }

        if (sub_map[col] != null)
            this._tile_container.RemoveChild(sub_map[col]);

            // 设置表现
        var sprite = new ALittle.Sprite(g_Control);
        sprite.texture_name = "tile.png";
        sprite.width = 32 / 4;
        sprite.height = 32 / 4;
        sprite.x = col * sprite.width;
        sprite.y = row * sprite.height;
        sprite.row_count = 4;
        sprite.col_count = 7 * 4;
        sprite.row_index = row % 4 + 1;
        sprite.col_index = col % 4 + 1 + (type - 1) * 4;
        this._tile_container.AddChild(sprite);

        sub_map[col] = sprite;
    }

    private fun TryRemoveWall(int row, int col) : bool
    {
        var sub_map = this._sprite_map[row];
        if (sub_map == null) return false;

        var sprite = sub_map[col];
        if (sprite == null) return false;

        if (sprite.col_index >= (BrushType.BT_WALL - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_WALL) * 4)
        {
            this._tile_container.RemoveChild(sprite);
            sub_map[col] = null;
            return true;
        }
        return false;
    }

    private fun RemoveTileShow(int row, int col)
    {
        var sub_map = this._sprite_map[row];
        if (sub_map == null) return;
    
        if (sub_map[col] != null)
        {
            this._tile_container.RemoveChild(sub_map[col]);
            sub_map[col] = null;
        }
    }

    public fun CanWalkByMap(int row, int col) : bool
    {
        var sub_map = this._sprite_map[row];
        if (sub_map == null) return true;

        var sprite = sub_map[col];
        if (sprite == null) return true;

        return sprite.col_index >= (BrushType.BT_GRASS - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_GRASS) * 4;
    }

    public fun Collision(double left, double top, double right, double bottom, ALittle.DisplayObject target) : bool
    {
        var not_check = right < target.x || bottom < target.y || target.x + target.width < left || target.y + target.height < top;
        return !not_check;
    }

    public fun CanWalkByEntity(BattleRole entity, double left, double top, double right, double bottom) : bool
    {
        if (this._player_1.parent != null && entity != this._player_1 && this.Collision(left, top, right, bottom, this._player_1)) return false;
        if (this._player_2.parent != null && entity != this._player_2 && this.Collision(left, top, right, bottom, this._player_2)) return false;
        for (var role, _ in this._enemy_map)
        {
            if (role != entity && this.Collision(left, top, right, bottom, role))
            	return false;
        }
        return true;
    }
    
    // 返回值1：是否碰撞
    // 返回值2：是否需要爆炸
    public fun BulletCollisionByEntity(BattleBullet bullet, double left, double top, double right, double bottom) : bool, bool
    {
        if (bullet.role.is_enemy && this._player_1.parent != null && bullet.role != this._player_1 && this._player_1.alive && this.Collision(left, top, right, bottom, this._player_1))
            return true, this._player_1.BeAttack();

        if (bullet.role.is_enemy && this._player_2.parent != null && bullet.role != this._player_2 && this._player_1.alive && this.Collision(left, top, right, bottom, this._player_2))
            return true, this._player_2.BeAttack();

        if (!bullet.role.is_enemy)
        {
            for (var role, _ in this._enemy_map)
            {
                if (role != bullet.role && role.alive && this.Collision(left, top, right, bottom, role))
                    return true, role.BeAttack();
            }
        }
        return false, false;
    }

    public fun BulletCollisionByMap(int row, int col, bool min_or_max, int dir) : bool
    {
        var sub_map = this._sprite_map[row];
        if (sub_map == null) return false;

        var sprite = sub_map[col];
        if (sprite == null) return false;

        // 如果是铁
        if (sprite.col_index >= (BrushType.BT_IRON - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_IRON) * 4)
        	return true;

        // 如果是草
        if (sprite.col_index >= (BrushType.BT_GRASS - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_GRASS) * 4)
        	return false;

        // 如果是河
        if (sprite.col_index >= (BrushType.BT_RIVER - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_RIVER) * 4)
        	return false;
        if (sprite.col_index >= (BrushType.BT_RIVER2 - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_RIVER2) * 4)
        	return false;

        // 如果是城堡
        if (sprite.col_index >= (BrushType.BT_CASTLE2 - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_CASTLE2) * 4)
        	return false;
        if (sprite.col_index >= (BrushType.BT_CASTLE - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_CASTLE) * 4)
        {
            // 整个鸟巢作为废墟
            for (var r = 12*4; r < 13*4; 1)
            {
                for (var c = 6*4; c < 7*4; 1)
                	this.SetTileShow(r, c, BrushType.BT_CASTLE2);
            }
        	return true;
        }

        // 如果是墙
        if (sprite.col_index >= (BrushType.BT_WALL - 1) * 4 + 1 && sprite.col_index <= (BrushType.BT_WALL) * 4)
        {
            if (dir == DirType.DT_UP || dir == DirType.DT_DOWN)
            {
                this.TryRemoveWall(row, col);
                if (min_or_max)
                    this.TryRemoveWall(row, col - 1);
                else
                    this.TryRemoveWall(row, col + 1);
            }
            else
            {
                this.TryRemoveWall(row, col);

                if (min_or_max)
                	this.TryRemoveWall(row - 1, col);
                else
                    this.TryRemoveWall(row + 1, col);
            }
            return true;
        }

        return false;
    }

    public fun FireBullet(BattleRole role)
    {
        var bullet = g_Control.CreateControl{BattleBullet}("battle_bullet");
        if (role.dir == DirType.DT_UP)
        {
            bullet.x = role.x + role.width / 2 - bullet.width / 2;
            bullet.y = role.y;
        }
        elseif (role.dir == DirType.DT_RIGHT)
        {
            bullet.x = role.x + role.width - bullet.width;
            bullet.y = role.y + role.height / 2 - bullet.height / 2;
        }
        elseif (role.dir == DirType.DT_DOWN)
        {
            bullet.x = role.x + role.width / 2 - bullet.width / 2;
            bullet.y = role.y + role.height - bullet.height;
        }
        else
        {
            bullet.x = role.x;
            bullet.y = role.y + role.height / 2 - bullet.height / 2;
        }
        bullet.Init(role.dir, role);
        this._bullet_container.AddChild(bullet);
        this._bullet_map[bullet] = true;
    }

    public fun GenerateEnemy()
    {
        // 随机出生点
        var born_pos = new List<int>();
        born_pos[1] = 0;
        born_pos[2] = 6;
        born_pos[3] = 12;

        // 洗牌
        ALittle.List_Shuffle(born_pos);

        for (var index, pos in born_pos)
        {
            var failed = false;
            // 内部格子是否被占领
            for (var row = 0; row < 4; 1)
            {
                for (var col = pos * 4; col < (pos + 1) * 4; 1)
                {
                    if (!this.CanWalkByMap(row, col))
                    {
                        failed = true;
                        break;
                    }
                }

                if (failed) break;
            }

            if (!failed)
            {
                var left = pos * 4 * this._cell_size;
                var right = left + this._enemy_width;
                if (!this.CanWalkByEntity(null, left, 0, right, this._enemy_height))
                    failed = true;
            }

            if (!failed)
            {
                this._enemy_tiletable.RemoveChild(this._enemy_tiletable.childs[this._enemy_tiletable.child_count]);
                var enemy = g_Control.CreateControl{BattleEnemy}("battle_enemy");
                this._enemy_map[enemy] = true;
                enemy.StartBorn(0, pos * 4, ALittle.Math_RandomInt(1, 3), DirType.DT_DOWN, ALittle.Math_RandomInt(1, 100) > 80);
                this._entity_container.AddChild(enemy);
                this._enemy_count += 1;
                this._generate_enemy_cool = 1000;
                break;
            }
        }
    }

    public get map_size() : double { return this._tile_container.width; }

    private fun Start()
    {
        if (g_GCenter.player_count >= 1)
        {
            this._entity_container.AddChild(this._player_1);
            this._player_1.StartBorn(12 * 4, 4* 4 + 2, g_GCenter.player1_data.level, DirType.DT_UP, 0.08);
        }

        if (g_GCenter.player_count >= 2)
        {
            this._entity_container.AddChild(this._player_2);
            this._player_2.StartBorn(12 * 4, 8* 4 - 2, g_GCenter.player2_data.level, DirType.DT_UP, 0.08);
        }
    }

    private fun HandleFrame(int frame_time)
    {
        // 尝试生成敌军
        if (this._enemy_count < 4)
        {
            this._generate_enemy_cool -= frame_time;
            if (this._generate_enemy_cool <= 0)
            	this.GenerateEnemy();
        }

        if (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_A])
        {
            if (this._player_1.parent != null && this._player_1.alive)
            	this._player_1.Walk(DirType.DT_LEFT, frame_time);
        }
		elseif (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_W])
        {
            if (this._player_1.parent != null && this._player_1.alive)
            	this._player_1.Walk(DirType.DT_UP, frame_time);
        }
		elseif (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_S])
        {
            if (this._player_1.parent != null && this._player_1.alive)
            	this._player_1.Walk(DirType.DT_DOWN, frame_time);
        }
        elseif (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_D])
        {
            if (this._player_1.parent != null && this._player_1.alive)
            	this._player_1.Walk(DirType.DT_RIGHT, frame_time);
        }

        if (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_LEFT])
        {
            if (this._player_2.parent != null && this._player_2.alive)
            	this._player_2.Walk(DirType.DT_LEFT, frame_time);
        }
		elseif (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_UP])
        {
            if (this._player_2.parent != null && this._player_2.alive)
            	this._player_2.Walk(DirType.DT_UP, frame_time);
        }
        elseif (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_DOWN])
        {
            if (this._player_2.parent != null && this._player_2.alive)
            	this._player_2.Walk(DirType.DT_DOWN, frame_time);
        }
        elseif (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_RIGHT])
        {
            if (this._player_2.parent != null && this._player_2.alive)
            	this._player_2.Walk(DirType.DT_RIGHT, frame_time);
        }

        if (this._player_1.parent != null) this._player_1.UpdateFrame(frame_time);
        if (this._player_2.parent != null) this._player_2.UpdateFrame(frame_time);
        for (var enemy, _ in this._enemy_map) enemy.UpdateFrame(frame_time);
        for (var bullet, _ in this._bullet_map) bullet.UpdateFrame(frame_time);
    }

    private fun HandleKeyDown(int mod, int sym, int scancode)
    {
        if (sym == ALittle.UIEnumTypes.KEY_J)
        {
            if (this._player_1.parent != null && !this._player_1.alive) return;
            this._player_1.Fire();
        }

        if (sym == ALittle.UIEnumTypes.KEY_1)
        {
            if (this._player_2.parent != null && !this._player_2.alive) return;
            this._player_2.Fire();
        }
    }

    public fun RoleDeath(BattleRole role)
    {
        this._entity_container.RemoveChild(role);

        if (role == this._player_1)
        {
            if (g_GCenter.player_count >= 1 && g_GCenter.player1_data.life > 0)
            {
                g_GCenter.player1_data.life -= 1;
                g_GCenter.player1_data.level = 1;
                this._player1_life.text = g_GCenter.player1_data.life;
                this._entity_container.AddChild(this._player_1);
                this._player_1.StartBorn(12 * 4, 4* 4 + 2, g_GCenter.player1_data.level, DirType.DT_UP, 0.08);
            }
        }
        elseif (role == this._player_2)
        {
            if (g_GCenter.player_count >= 2 && g_GCenter.player2_data.life > 0)
            {
                g_GCenter.player2_data.life -= 1;
                g_GCenter.player2_data.level = 1;
                this._player2_life.text = g_GCenter.player2_data.life;
                this._entity_container.AddChild(this._player_2);
                this._player_2.StartBorn(12 * 4, 4* 4 + 2, g_GCenter.player2_data.level, DirType.DT_UP, 0.08);
            }
        }
        else
        {
            this._enemy_map[role] = null;
            this._enemy_count -= 1;
        }
    }

    public fun BulletDeath(BattleBullet bullet)
    {
        this._bullet_container.RemoveChild(bullet);
        this._bullet_map[bullet] = null;
    }
}
