
namespace BattleCity;

public class BattleRole : ALittle.DisplayLayout
{
	private ALittle.FramePlay _effect_born;
	private ALittle.FramePlay _effect_shield;
    private ALittle.FramePlay _effect_explosion;
	private ALittle.Sprite _sprite;

    private int _level = 1;
    private int _dir = 1;

    private int _bullet_total = 1;
    private int _bullet_count = 0;

    private double _speed = 0;

    public fun TCtor()
    {
        this._sprite.visible = false;
        this._effect_born.visible = false;
        this._effect_shield.visible = false;
        this._effect_explosion.visible = false;
    }

    public get is_enemy() : bool { return false; }

    public get alive() : bool
    {
        if (this._effect_born.visible) return false;
        if (this._effect_explosion.visible) return false;
        return true;
    }

    public get dir() : int { return this._dir; }
    public get level() : int { return this._level; }

    public fun StartExplosion()
    {
        this._sprite.visible = false;
        this._effect_explosion.visible = true;
        this._effect_explosion.Play();

        var loop = new ALittle.LoopTimer(bind(this.HandleExplosionEnd, this), 1000);
        loop.Start();
    }

    public fun StartShield()
    {
        this._effect_shield.visible = true;
        this._effect_shield.Play();

        var loop = new ALittle.LoopTimer(bind(this.HandleShieldStop, this), 5000);
        loop.Start();
    }

    public fun UpdateFrame(int frame_time)
    {
    }

    private fun UpdateWalk(int frame_time)
    {
    }

    // 返回值：是否需要爆炸
    public fun BeAttack() : bool
    {
        return true;
    }

    public fun Fire()
    {
        if (this._bullet_count >= this._bullet_total) return;
        this._bullet_count += 1;
        g_GCenter.battle_scene.FireBullet(this);
    }

    public fun Walk(int dir, int frame_time) : bool
    {
        var walk = (this._dir == dir);
        this._dir = dir;
        this.UpdateWalk(frame_time);

        if (this._dir == DirType.DT_UP)
        {
            var col_min = ALittle.Math_Floor(this.x / g_GCenter.battle_scene.cell_size);
            var col_max = ALittle.Math_Floor((this.x + this.width - 1) / g_GCenter.battle_scene.cell_size);

            var cur_row = ALittle.Math_Floor(this.y / g_GCenter.battle_scene.cell_size);
            var y = this.y - frame_time * this._speed;
            if (y <= 0) y = 0;
            var next_row = ALittle.Math_Floor(y / g_GCenter.battle_scene.cell_size);
            var target = this.y;
            for (var row = cur_row; row >= next_row; -1)
            {
                var failed = false;
                for (var col = col_min; col <= col_max; 1)
                {
                    if (!g_GCenter.battle_scene.CanWalkByMap(row, col))
                    {
                        failed = true;
                        break;
                    }
                }
                if (failed) break;
                target = row * g_GCenter.battle_scene.cell_size;
            }
            if (target < y) target = y;

            if (!g_GCenter.battle_scene.CanWalkByEntity(this, this.x, target, this.x + this.width, target + this.height))
                return false;

            if (this.y == target) return false;
            this.y = target;
            return true;
        }

        if (this._dir == DirType.DT_DOWN)
        {
            var col_min = ALittle.Math_Floor(this.x / g_GCenter.battle_scene.cell_size);
            var col_max = ALittle.Math_Floor((this.x + this.width - 1) / g_GCenter.battle_scene.cell_size);

            var bottom = this.y + this.height;
            var cur_row = ALittle.Math_Floor(bottom / g_GCenter.battle_scene.cell_size);
            var y = bottom + frame_time * this._speed;
            if (y >= g_GCenter.battle_scene.map_size) y = g_GCenter.battle_scene.map_size;
            var next_row = ALittle.Math_Floor(y / g_GCenter.battle_scene.cell_size);
            var target = bottom;
            for (var row = cur_row; row <= next_row; 1)
            {
                var failed = false;
                for (var col = col_min; col <= col_max; 1)
                {
                    if (!g_GCenter.battle_scene.CanWalkByMap(row, col))
                    {
                        failed = true;
                        break;
                    }
                }
                if (failed) break;
                target = (row + 1) * g_GCenter.battle_scene.cell_size;
            }
            if (target > y) target = y;

            if (!g_GCenter.battle_scene.CanWalkByEntity(this, this.x, target - this.height, this.x + this.width, target))
                return false;
            if (this.y == target - this.height) return false;
            this.y = target - this.height;

            return true;
        }

        if (this._dir == DirType.DT_LEFT)
        {
            var row_min = ALittle.Math_Floor(this.y / g_GCenter.battle_scene.cell_size);
            var row_max = ALittle.Math_Floor((this.y + this.height - 1) / g_GCenter.battle_scene.cell_size);

            var cur_col = ALittle.Math_Floor(this.x / g_GCenter.battle_scene.cell_size);
            var x = this.x - frame_time * this._speed;
            if (x <= 0) x = 0;
            var next_col = ALittle.Math_Floor(x / g_GCenter.battle_scene.cell_size);
            var target = this.x;
            for (var col = cur_col; col >= next_col; -1)
            {
                var failed = false;
                for (var row = row_min; row <= row_max; 1)
                {
                    if (!g_GCenter.battle_scene.CanWalkByMap(row, col))
                    {
                        failed = true;
                        break;
                    }
                }
                if (failed) break;
                target = col * g_GCenter.battle_scene.cell_size;
            }
            if (target < x) target = x;
            if (!g_GCenter.battle_scene.CanWalkByEntity(this, target, this.y, target + this.width, this.y + this.height))
                return false;
            if (this.x == target) return false;
            this.x = target;
            return true;
        }

        if (this._dir == DirType.DT_RIGHT)
        {
            var row_min = ALittle.Math_Floor(this.y / g_GCenter.battle_scene.cell_size);
            var row_max = ALittle.Math_Floor((this.y + this.height - 1) / g_GCenter.battle_scene.cell_size);

            var right = this.x + this.width;
            var cur_col = ALittle.Math_Floor(right / g_GCenter.battle_scene.cell_size);
            var x = right + frame_time * this._speed;
            if (x >= g_GCenter.battle_scene.map_size) x = g_GCenter.battle_scene.map_size;
            var next_col = ALittle.Math_Floor(x / g_GCenter.battle_scene.cell_size);
            var target = right;
            for (var col = cur_col; col <= next_col; 1)
            {
                var failed = false;
                for (var row = row_min; row <= row_max; 1)
                {
                    if (!g_GCenter.battle_scene.CanWalkByMap(row, col))
                    {
                        failed = true;
                        break;
                    }
                }
                if (failed) break;
                target = (col + 1) * g_GCenter.battle_scene.cell_size;
            }
            if (target > x) target = x;
            if (!g_GCenter.battle_scene.CanWalkByEntity(this, target - this.width, this.y, target, this.y + this.height))
                return false;
            if (this.x == target - this.width) return false;
            this.x = target - this.width;
        
            return true;
        }

        return false;
    }

    private fun HandleExplosionEnd()
    {
        var loop = new ALittle.LoopTimer(bind(g_GCenter.battle_scene.RoleDeath, g_GCenter.battle_scene, this), 0);
        loop.Start();
    }

    private fun HandleShieldStop()
    {
        this._effect_shield.visible = false;
        this._effect_shield.Stop();
    }

    public fun AddBullet()
    {
        if (this._bullet_count == 0) return;
        this._bullet_count -= 1;
    }

    public fun Clear()
    {
        this._effect_born.Stop();
        this._effect_shield.Stop();
        this._effect_explosion.Stop();
    }
}
